<html>
<head>
  <meta charset="utf-8" />
  <title>Diskache</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Diskache: disk caching utility">
  <meta name="author" content="Victor Milovanov">

  <!-- Bootstrap Core CSS -->
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <!-- Clean CSS -->
  <link href="css/clean-blog.min.css" rel="stylesheet">

  <link href="css/diskache.css" rel="stylesheet" />

  <!-- Custom Fonts -->
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

  <!-- jQuery -->
  <script src="js/jquery.js"></script>
  <!-- Bootstrap Core JavaScript -->
  <script src="js/bootstrap.min.js"></script>
  <!-- Custom Theme JavaScript -->
  <script src="js/clean-blog.min.js"></script>

  <script src="js/diskache.js"></script>
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header page-scroll">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="index.html">Home</a>
          </li>
          <li>
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Tech</a>
            <ul class="dropdown-menu">
              <li><a href="trim.html">TRIM</a></li>
              <li>
                <a href="ioschedule.html">I/O Scheduling</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="about.html">About</a>
          </li>
          <li>
            <a href="contact.html">Contact</a>
          </li>
        </ul>
      </div>
      <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
  </nav>

  
<header class="intro-header empty">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      </div>
    </div>
  </div>
</header>

<!-- Main Content -->
<article>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <h3>I/O in the prototype</h3>
        <p>
          Windows talks to disk drivers by means of sending I/O request packets. Diskache prototype
          puts them into a queue, and executes one by one in the order they arrived (FIFO).
        </p>

        <p>
          It dequeues a packet, and, if the requested data is already cached, serves it
          directly from the fast disk. Otherwise, Diskache passes the request to the main storage. It
          might also decide to move this block to the fast disk, if the data is used often. In this case
          Diskache will wait for a block in cache to be ready (usually, there are plenty of them already prepared
          by a background thread), put the data there, and update information about cache contents.
        </p>

        <p>
          Diskache then notifies Windows, that I/O request is completed, and picks up the next one.
          This is a long process with only one disk involved at the same time. The other storage unit is idle.
        </p>

        <h3>Asynchronous I/O</h3>
        <p>
          It is not necessary to wait for the last request to complete before picking up the next one.
          If a request is being served from cache, and the next request in the queue is known to require main
          storage access, it can be started immediately. While slower main storage is busy serving a request,
          Diskache can manage to complete many I/O packets for cached data.
        </p>

        <h3>I/O Scheduling</h3>
        <p>
          This can be extended further: even if no main storage requests have been picked up yet,
          Diskache could go ahead, and scan the entire queue for such a packet, and start executing it
          in advance.
        </p>
        <p>
          In general, Diskache could reorder some requests to optimize load between the cache and the
          main storage. For example, when the packet queue is full, but no request is meant for the main storage,
          Diskache could pick up a request from the end of the queue, and forward it to the main storage hoping
          it will be completed by the time its turn would come normally.
        </p>

        <h3>The Challenge</h3>
        <p>
          While it might sound easy to do, this is actually quite hard to achieve. Diskache maintains
          an internal data structure, which contains information about blocks, stored in the cache.
          The main problem is ensuring integrity of that structure in case of power failure.
        </p>

        <p>
          Each write operation, which allocates a new entry in the cache, requires an update to this structure,
          and an actual data write. Hardware reset might happen between them. If the original block address is changed
          for an entry, but the data is not updated, next read at this address will return data from a wrong block,
          which totally ruins integrity. An opposite situation has a similar problem.
        </p>

        <p>
          In the prototype (with its sequential request execution), this situation can be easily caught by
          maintaining a linear operation log. After reset, it will be clear which operations succeeded, and which
          did not. An appropriate action can be taken to correct the situation. If Diskache schedules I/O,
          linear log will no longer be enough, and rolling back or retrying multiple operations, interrupted
          on different phases of execution, will be required.
        </p>
      </div>
    </div>
  </div>
</article>


  <hr />

  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          <ul class="list-inline text-center">
            <li>
              <a href="#">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            <li>
              <a href="#">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            <li>
              <a href="#">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          </ul>
          <p class="copyright text-muted">Copyright &copy; Lost Tech LLC 2015</p>
          <p class="copyright text-muted photo-credit">Site design: <a href="http://www.ironsummitmedia.com/">Iron Summit Media Strategies, LLC</a></p>
        </div>
      </div>
    </div>
  </footer>
</body>
</html>